// Лекция 4: Двумерные массивы и рекурсия

// 1.Двумерные массивы
// Как читаются Как пишутся Как выглядят
// И Как их записать ввиде кода.

// string[,] - тип двумерного массива

// Создадим новый массив типа string.
// В нём [2,5] - 2 строчки и 5 столбцов.

// string[,] table = new string[2, 5];

// Индексация и столбцов и  строк начинается с 0.
// table[0,0] table[0,1] table[0,2] table[0,3] table[0,4]
// table[1,0] table[1,1] table[1,2] table[1,3] table[0,4]
// String.Empty - по умолчанию инициализация строк .
// Для обращения к определённому элементу массива указываем название массива
// и номер строки и столбца. Запишем в неё "слово";

/*
table[1, 2] = "слово";
// Для реализации массива используем цикл в цикле
// Во внешнем цикле рабочей переменной будет rows(с англ. - ряды)
// Во внутреннем цикле будет columns(с англ. - колонки)
for (int rows = 0; rows < 2; rows++)
{
    for (int columns = 0; columns < 5; columns++)
    { //Выведем результат в терминал
        Console.WriteLine($"-{table[rows, columns]}-");
    }
}
*/
/*
// Теперь тоже самое сделаем с числами.
// Инициализируем новый массив int[,] matrix
// В нём 3 строки и 4 столбца.
//int[,] matrix = new int[3,4];
// Создадим метод для вывода матрицы на экран и замолнения её числами.
// Обрамим в {} то что делали ранее ( цикл в цикле ).
// В качестве аргументов запишем целоцисленный двумерный массив.
void PrintArrayM(int[,] matr)
{
    // Во внешнем цикле рабочей переменной будет i - это будут строки
    // Во внутреннем цикле будет j - это будут столбцы.
    for (int i = 0; i < matr.GetLength(0); i++)
    {
        for (int j = 0; j < matr.GetLength(1); j++)
        { // выведем на экран с помощью интерполяции.
            Console.Write($"{matr[i, j]} ");
        }// Вывод осуществим через обычный Write В сообщении поставим пробел.
        Console.WriteLine(); //После замершения работы внутреннеего цикла вывод новой строки
                             // будет демонстрироваться с новой строки.
                             // Результат - матрица (прямогугольная таблица чисел) у каторой 3 строки 4 столбца.
    }
}
// Создадим метод для заполнения массива числами.
// Аргументы - двумерный массив с целыми числами int[,].
// Как и в предыдущем методе matrix.GetLength(0) во внешний(строки) цикл а
// matrix.GetLength(1) - во внутренний(столбцы) .
void FillArrayM(int[,] matr)
{
    for (int i = 0; i < matr.GetLength(0); i++)
    {
        for (int j = 0; j < matr.GetLength(1); j++)
        {// Обращаясь к текущим индексам массива [строка,столбец] заполняем
            matr[i,j] = new Random().Next(1, 10); // [1,10) - 10 не входит!
        }// с помощью генератора случайных чисел значением
    }
}
// Перенесём инициализацию поближе к вызову метода вывода.
int[,] matrix = new int[3, 4];
// Вызовем метод вывода.
PrintArrayM(matrix); // Демонстрируем что он заполненн 0.
// Вызываем метод заполнения массива
FillArrayM(matrix);
Console.WriteLine(); // Строка для разделения матриц.
PrintArrayM(matrix); // Демонстрируем уже заполненный массив.
*/

/*
// 2 Рисование с помощью двумерных массивов.И Рекурсия в деле.
Рекурсия это метод в методе
// Для закраски определённой облаяти будем использовать следующую
// схему движения курсора в двумерном массиве.
// 1 Определим изначальную точку : 
// x - строка, y - столбец x,y - положение точки
// 2 Схема такая:
// Если закрашено вверх там проверили
// Если закрашено вернулись и влево
// Если закрашено вернулись и вниз
// Если закрашено вернулись и вправо.
// 3 Ввиде координат:
// Если 1 то x-1,y 
// Если 1 то вернулись x,y-1 
// Если 1 то вернулись x+1,y
// Если 1 то врнулись x,y+1


// Перересую картику в ручную из видеолекции.
// Картинка плец вверх из 0 и едениц. В назавании новый двумерный массив.
// не обязательно указывать количество строк и столбцов если данные фиксированые.
int[,] pic = new int[,]
{
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    {0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    {0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
    {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
    {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
    {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
    {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
    {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
    {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
    {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
    {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
    {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 },
    {0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
    {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};

// Создадим метод для вывода этого массива

// Изменим его для , большей наглядности. Изменим название входного аргумента на Image
// и само название метода. И во внутреннем цикле поменяем действия
// В том случае когда в позиции текущего элемента будет 0 поменяем его на " ".
// В том случае когда в позиции текущего элемента будет 1 поменяем его на "+".
void PrintImage(int[,] image)
{
    for (int i = 0; i < image.GetLength(0); i++)
    {
        for (int j = 0; j < image.GetLength(1); j++)
        {
            if (image[i, j] == 0) Console.Write($" ");
            else Console.Write($"+");
        }
        Console.WriteLine();
    }
}

// Опишем метод который будет закрашивать картинку:
// В качестве аргументов укажем позицию строки int row и пикселя int col
// с каторого будет начинаться закраска.
// Создадим условие if : если текущая позиция "матрицы" не закрашена то в ней
// закрашиваем текущий элемент
// и добавляем схему движения курсора в виде САМОГО МЕТОДА "FillImage".
void FillImage(int row, int col)
{
    if (pic[row,col]==0)
    {
        pic[row,col] = 1;
        FillImage(row-1,col);
        FillImage(row,col-1);
        FillImage(row+1,col);
        FillImage(row,col+1);
    }
}
// Вызовем этот метод. В качестве аргумента передадим массив с рисунком
PrintImage(pic);
// Вызовем метод закраски и укажем, к примеру 13,13, расположение незакрашеного
// элемента внутри "картинки".
FillImage(13,13);
PrintImage(pic);
*/

/*
// 3.Задача с факториалом.
// Формула факториала 5 с представлением рекурсии:
// 5! = 5*4*3*2*1
//      5*4!
//        4*3!
//          3*2!
//            2*1
// Создадим метод для нахождения любого факториала в виде рекурсии
// Метод принимает в себя int число и возвращает int число.

double Factorial(int n)
{
    if (n == 1) return 1; // так как 1! = 1
    else return n * Factorial(n - 1);
// Иначе, нужно взять текущее число и умножить на факториал предыдущего(n-1).
}
// Проверим код. Обратимся к методу, выводя его в терминал. 
// В аргументах указав число.

// Применим цикл for для демонстрации каждого факториала в консоли
// Для этого рабочую переменную установим как 1 а в обращении к факториалу
// установим текущую позицию индекса.
// C помощью интоерполяции строки изменим сообщение так чтобы оно демонстрировало
// Каждый факториал
for (int i = 1; i < 40; i++)
{
    Console.WriteLine($"{i}!={Factorial(i)}");
}
// На 17! терминал начинает показывать отрицательные числа.
// Это связано с тем что тип int32 не может демонстрировать такие большие значения.
// Для этого для начала изменим тип int32 на double в методе Factorial.
*/

/*
// 4. Числа фибоначи(каждое следующее число задаётся через предыдущее).
//  1  1  2  3  5  8  13  21 ...
// f(1) = 1
// f(2) = 1
// f(n) = f(n-1) + f(n-2)

// Напишем метод в виде кода.
// Метод берёт целое число n и возвращает также целое число
double Fibonahcci(int n)
{ //если заданое число 1 или 2 то вернём результат 1(по условию)
    if (n==1 || n==2) return 1;
    else return Fibonahcci(n-1)+Fibonahcci(n-2);
  //иначе соответственно формуле чисел фибоначи , вместо f - Этот же метод.
}
// Как и в прошлой задаче реализуем демонстрацию через цикл for.
// Так же поменяем тип возвращаемых значений на double и посчитаем до 40 чисел.
for (int n = 1; n < 40; n++)
{
    Console.WriteLine($"f({n})={Fibonahcci(n)}");
}
// После 30 числа компьютер начинает работать медленно .  
*/




// matrix.GetLength(1) - это команда для определения количества столбцов в двумерном массиве
// matrix.GetLength(0) - это команда для определения количества строк в двумерном массиве
// они используются в цикле for к примеру :
// for (int i = 0; i < matrix.GetLength(0); i++)